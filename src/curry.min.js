"use strict";function styleProp(el,property){return window.getComputedStyle(el,null).getPropertyValue(property)}function isObj(value){let type=typeof value;return null!=value&&("object"==type||"function"==type)}function isArr(value){return Array.isArray(value)}function isNil(value){return null==value}function from(n,start=0){return Array.from({length:n},(_,i)=>i+start)}function undef(property,def){return isNil(property)?def:property}function isFunc(func){return"[object Function]"==Object.prototype.toString.call(func)}function delay(ms){return new Promise(resolve=>setTimeout(resolve,ms))}function bez(...args){if("string"==typeof args[0]&&1===args.length){const bezoars={easeInSine:[.12,0,.39,0],easeOutSine:[.61,1,.88,1],easeInOutSine:[.37,0,.63,1],easeInCubic:[.32,0,.67,0],easeOutCubic:[.33,1,.68,1],easeInOutCubic:[.65,0,.35,1],easeInQuint:[.64,0,.78,0],easeOutQuint:[.22,1,.36,1],easeInOutQuint:[.83,0,.17,1],easeInCirc:[.55,0,1,.45],easeOutCirc:[0,.55,.45,1],easeInOutCirc:[.85,0,.15,1],easeInQuad:[.11,0,.5,0],easeOutQuad:[.5,1,.89,1],easeInOutQuad:[.45,0,.55,1],easeInQuart:[.5,0,.75,0],easeOutQuart:[.25,1,.5,1],easeInOutQuart:[.76,0,.24,1],easeInExpo:[.7,0,.84,0],easeOutExpo:[.16,1,.3,1],easeInOutExpo:[.87,0,.13,1],easeInBack:[.36,0,.66,-.56],easeOutBack:[.34,1.56,.64,1],easeInOutBack:[.68,-.6,.32,1.6]},bez=args[0];if(bezoars[bez])return`cubic-bezier(${bezoars[bez].join(",")})`;throw Error(`Selected easing function "${bez}" doesn't exist.`)}const format=args.map(item=>Math.max(Math.min(item,1),0));return`cubic-bezier(${format.join(",")})`}function bindListener(el,name,callback,$state,options){el.addEventListener(name,e=>{callback.apply(el,[{event:e,e:e,self:el,$util:$util,$state:$state}])},options)}function map(elements,callback){if(void 0!==elements.length)for(let i=0;i<elements.length;i++){const shouldBreak=callback.apply(elements[i],[elements[i],i]);if(shouldBreak)break}}function render(tag,attrs,children){return("string"==typeof attrs||"number"==typeof attrs||Array.isArr(attrs))&&(children=attrs,attrs={}),isNil(children)||(Array.isArr(children)?"string"==typeof children[0]&&(children=children[0]):children=`${children}`),{tag:tag,attrs:attrs,children:children}}function getSiblingIndex(el){if(!el)return 0;let i=0,cloned=el;for(;null!=(cloned=cloned.previousElementSibling);)i++;return i}function createElement(vnode,container,where){if(isArr(vnode))return void vnode.map(node=>createElement(node,container,where));const el=vnode.el=document.createElement(vnode.tag);if(vnode.attrs)for(const key in vnode.attrs){let value=vnode.attrs[key];el.setAttribute(key,value)}switch(vnode.children&&("string"==typeof vnode.children?el.textContent=vnode.children:vnode.children.forEach(child=>{"string"==typeof child?el.textContent+=" "+child:createElement(child,el)})),where){case"prepend":container.parentNode.insertBefore(el,container);break;case"append":container.parentNode.insertBefore(el,container.nextSibling);break;case"prependchild":container.insertBefore(el,container.firstChild);break;case"appendchild":default:container.appendChild(el)}return el}const formatAnimationOptions=(options={})=>({length:undef(options.length,500),easing:undef(options.easing,"ease-in-out"),callback:options.callback}),$util={styleProp:styleProp,isObj:isObj,isArr:isArr,isNil:isNil,isFunc:isFunc,from:from,render:render,mapElements:map,getSiblingIndex:getSiblingIndex,undef:undef,bez:bez,delay:delay};function queryElement(selector){return isObj(selector)||selector.nodeType?[selector]:document.querySelectorAll(selector)}!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?module.exports=factory():"function"==typeof define&&define.amd?define(factory):(global=global||self).$=factory()}(this,(function(){const $state={},$=selector=>{let element;if(!selector)throw Error("Selector cannot be empty.");if("string"==typeof selector&&selector.startsWith("$"))switch(selector){case"$state":return $state;case"$util":return $util;default:return void console.warn("[$()] Unsupported magic selector.")}element=queryElement(selector),$.get=property=>{if(element&&0!==element.length){if(property&&void 0!==element.lengtj){const params=[];return map(element,node=>{node[property]&&params.push(node[property])}),params}return element}},$.del=()=>{element&&map(element,node=>{node.remove()})},$.on=(event,callback,options)=>element&&0!==element.length?(map(element,node=>{bindListener(node,event,callback.bind(node),$state,options)}),$):$,$.css=(property,style)=>element&&0!==element.length?property?"string"==typeof property&&"string"==typeof style?(map(element,node=>{node.style[property]=style}),!0):isObj(property)?(Object.entries(property).map(([key,value])=>{map(element,node=>{node.style[key]=value})}),!0):void 0:(console.warn("[$.css] No style entered, this chain node will be skipped."),$):$,$.addClass=classNames=>element&&0!==element.length?classNames&&0!==classNames.length?isArr(classNames)?(map(element,node=>{classNames.map(item=>node.classList.add(item))}),$):"string"==typeof classNames?(map(element,node=>{node.classList.add(classNames)}),$):void 0:(console.warn("[$.addClass] No class name(s) entered, this chain node will be skipped."),$):$,$.delClass=classNames=>element&&0!==element.length?classNames&&0!==classNames.length?isArr(classNames)?(map(element,node=>{classNames.map(item=>node.classList.remove(item))}),$):"string"==typeof classNames?(map(element,node=>{node.classList.remove(classNames)}),$):void 0:(console.warn("[$.delClass] No class name(s) entered, this chain node will be skipped."),$):$,$.toggleClass=classNames=>{if(!element||0===element.length)return $;if(!classNames||0===classNames.length)return console.warn("[$.toggleClass] No class name(s) entered, this chain node will be skipped."),$;const toggle=(cls,el)=>{el.classList.contains(cls)?el.classList.remove(cls):el.classList.add(cls)};if(isArr(classNames))return map(element,node=>{classNames.map(cls=>toggle(cls,node))}),$;"string"==typeof classNames&&map(element,node=>{toggle(classNames,node)})},$.each=callback=>{if(!element||0===element.length)return $;if(!callback)throw Error("Callback must be a function");let prev=null;return map(element,(node,index)=>{callback.apply(node,[{self:node,prev:prev,$util:$util,index:index,$state:$state}]),prev=node}),$},$.asyncEach=async callback=>{if(!element||0===element.length)return $;if(!callback)throw Error("Callback must be a function");let prev=null,index=0;for(const el of element)await new Promise(resolve=>callback.apply(el,[{self:el,prev:prev,$util:$util,index:index,next:resolve,$state:$state}])),prev=el,index+=1;return $},$.nth=(index,callback)=>{if(!element||0===element.length)return $;if(index>element.length)return console.warn(`[$.nth] Did not find element at specified index (${n}).`),$;if(index&&1!==index){for(let i=0;i<=element.length;i++)if(index-1===i){element=[element[i]];break}}else element=[element[0]];return callback&&callback.apply(element[0],[{self:element[0],$util:$util,index:index,$state:$state}]),$},$.nthChild=(n,callback)=>{if(!element||0===element.length)return $;const children=[];return map(element,node=>{if(n>node.children.length)return console.warn(`[$.nthChild] Did not find element's child at specified index (${n}).`),!0;n&&1!==n?map(node.children,(child,index)=>{n-1===index&&children.push(child)}):children.push(node.firstElementChild)}),children.map(child=>{callback&&callback.apply(child,[{self:child,$util:$util,$state:$state}])}),element=children,$},$.children=callback=>{if(!element||0===element.length)return $;const children=[];return map(element,node=>{children.push(...node.children),callback&&callback.apply(node.children,[{self:node.children,parent:node,$util:$util,$state:$state}])}),element=children,$},$.next=(index,callback)=>selectNTHSibling("next",index,callback),$.prev=(index,callback)=>selectNTHSibling("prev",index,callback);const selectNTHSibling=(selectType,index,callback)=>{if(!element||0===element.length)return $;const siblingPlace="next"===selectType?"nextElementSibling":"previousElementSibling";"number"!=typeof index&&(callback=index,index=null);const matches=[];return map(element,node=>{if(node[siblingPlace])if(index){const prev=node;for(let i=0;i<index;i++)if(node[siblingPlace]){matches.push(node[siblingPlace]);break}callback&&callback.apply(node,[{self:node,prev:prev,index:getSiblingIndex(node),$util:$util,$state:$state}])}else callback&&callback.apply(node,[{self:node[siblingPlace],prev:node,index:getSiblingIndex(node[siblingPlace]),$util:$util,$state:$state}]),matches.push(node[siblingPlace])}),element=matches,$};$.first=callback=>element&&0!==element.length?(element=[element[0]],callback&&callback.apply(element,[{self:element,$util:$util,$state:$state}]),$):$,$.last=callback=>{if(!element||0===element.length)return $;const index=element.length-1;return element=[element[index]],callback&&callback.apply(element,[{self:element,$util:$util,index:index,$state:$state}]),$},$.append=callback=>element&&0!==element.length?(map(element,node=>{const vdom="function"==typeof callback?callback.apply(node,[{self:node,render:render,$util:$util,$state:$state}]):callback;"string"==typeof vdom?node.insertAdjacentHTML("afterend",vdom):isNil(vdom)||createElement(vdom,node,"append")}),$):$,$.prepend=callback=>element&&0!==element.length?(map(element,node=>{const vdom="function"==typeof callback?callback.apply(node,[{self:node,render:render,$util:$util,$state:$state}]):callback;"string"==typeof vdom?node.insertAdjacentHTML("beforebegin",vdom):isNil(vdom)||createElement(vdom,node,"prepend")}),$):$,$.addChild=(callback,append=!0)=>element&&0!==element.length?(map(element,node=>{const vdom="function"==typeof callback?callback.apply(element,[{self:element,render:render,$util:$util,$state:$state}]):callback;"string"==typeof vdom?node.insertAdjacentHTML(append?"beforeend":"afterbegin",vdom):isNil(vdom)||createElement(vdom,node,append?"appendchild":"prependchild")}),$):$,$.text=(text,location="replace")=>{if(!element||0===element.length)return $;if(null==text){const texts=[];return map(element,node=>texts.push(node.textContent)),0===texts.lenght?texts[0]:texts}if(!["replace","prepend","append","before","after"].includes(location))return console.warn(`Function $.text(text, location) doesn't accept parameter "${location}" as a valid argument.`,"Please use 'replace', 'prepend' or 'append'. This chain node will be skipped."),$;const setText=(el,text,location)=>{switch(location){case"before":case"prepend":el.insertAdjacentText("afterbegin",text);break;case"after":case"append":el.insertAdjacentText("beforeend",text);break;default:case"replace":el.textContent=text}};return map(element,node=>{setText(node,text,location)}),$},$.show=(display="block")=>element&&0!==element.length?(map(element,node=>{node.style.display=display}),$):$,$.hide=()=>element&&0!==element.length?(map(element,node=>{node.style.display="none"}),$):$,$.toggle=(onActive="block")=>{if(!element||0===element.length)return $;const toggleSelf=(active,el,onActive)=>{active?$(el).hide():$(el).show(onActive)};return map(element,node=>{const isActive="none"!==styleProp(node,"display");toggleSelf(isActive,node,onActive)}),$},$.hover=functions=>{if(!element||0===element.length)return $;if(isObj(functions)&&!isFunc(functions)){const{enter:enter,leave:leave,options:options}=functions;enter&&leave?map(element,node=>{$(node).on("mouseenter",args=>enter.apply(node,[{...args}]),options),$(node).on("mouseleave",args=>leave.apply(node,[{...args}]),options)}):console.warn("[$.hover] Function $.hover({ enter, leave }) requires both parameters. This chain node will be skipped.")}else{if(!isFunc(functions))return console.warn("[$.hover] Did no provide callback. This chain node will be skipped."),$;{let cloned=[];map(element,(node,index)=>{cloned[index]=node.cloneNode(!0),$(node).on("mouseenter",args=>{functions.apply(node,[{...args}])}),$(node).on("mouseleave",()=>{const clone=cloned[index];node.removeAttribute("style"),node.classList=clone.classList,node.innerHTML=clone.innerHTML;const keepAttrs=[];for(;node.attributes.length>0;){const attr=node.attributes[0].name;node.removeAttribute(attr),$(clone).attr(attr)&&keepAttrs.push(attr)}keepAttrs.map(attr=>{node.setAttribute(attr,$(clone).attr(attr))})})})}}return $},$.click=(callback,options)=>element&&callback?(map(element,node=>{$(node).on("click",args=>callback.apply(node,[{...args}]),options)}),$):$,$.parent=callback=>{if(!element||0===element.length)return;const children=[];return map(element,node=>{if(node.parentNode){const parent=node.parentNode;callback&&callback.apply(parent,[{self:parent,child:node,$util:$util,$state:$state}]),children.push(parent)}}),element=children,$},$.filter=callback=>{if(!element||0===element.length)return $;if(!callback)return console.warn("[$.filter] No condition to iterate on, this chain node will be skipped."),$;const filtered=[];return map(element,(node,index)=>{const result=callback.apply(node,[{self:node,index:index,$util:$util,$state:$state}]);result&&filtered.push(node)}),element=filtered,$},$.animate=async(properties,options)=>{if(!element||!properties)return $;if(options=formatAnimationOptions(options),isFunc(properties)){const execute=properties;async function start(properties,options){options=formatAnimationOptions(options);const promises=[];return map(element,node=>{promises.push(applyAnimation(node,properties,options))}),Promise.all(promises)}await execute.apply(element,[{self:element,$util:$util,start:start,$state:$state}])}else map(element,node=>{applyAnimation(node,properties,options)});return $};const applyAnimation=async(el,properties,options)=>{const{length:length,easing:easing,callback:callback}=options,prevTransition=el.style.transition;let duration=length;return"string"==typeof length&&length.endsWith("s")&&(duration=1e3*parseFloat(length.slice(0,-1))),el.style.transition=`${duration/1e3}s all ${easing}`,new Promise(resolve=>{Object.entries(properties).map(([index,value])=>{const property=index;el.style[property]=value}),setTimeout(()=>resolve(),duration)}).then(()=>{el.style.transition=prevTransition,callback&&callback.apply(el,[{self:el,$util:$util,$state:$state}])})};return $.slideDown=(duration=500,easing="ease-in-out")=>{if(!element||0===element.length)return $;const sd=async el=>{el.style.display="block",el.style.transform="scale(1, 0)",await delay(1),$(el).animate({transform:"scale(1,1)"},{duration:duration,easing:easing,callback(){this.style.transformOrigin="inherit",this.style.transform="inherit"}})};return map(element,node=>{sd(node)}),$},$.slideUp=(duration=500,easing="ease-in-out")=>{if(!element||0===element.length)return $;const su=async el=>{el.style.transformOrigin="center top",await delay(1),setTimeout(()=>{$(el).animate({transform:"scale(1, 0)"},{duration:duration,easing:easing,callback(){this.style.display="none"}})},1)};return map(element,node=>{su(node)}),$},$.slideToggle=(duration=500,easing="ease-in-out")=>{if(!element||0===element.length)return $;const st=el=>{const display=styleProp(el,"display");"none"===display?$(el).slideDown(duration,easing):$(el).slideUp(duration,easing)};return map(element,node=>{st(node)}),$},$.is=(condition,apply="every")=>{if(!element||0===element.length)return!1;isArr(condition)&&(["some","every","none"].includes(apply)||console.warn('[$.is] Uknown condition method used. Please use "some", "every" or "none". \nAutomatically defaults to "every".'));const matches=(el,selector)=>(el.matches||el.matchesSelector||el.msMatchesSelector||el.mozMatchesSelector||el.webkitMatchesSelector||el.oMatchesSelector).call(el,selector);for(const node of element)if(isArr(condition))switch(apply){case"some":return condition.some(item=>matches(node,item));case"none":return!condition.every(item=>matches(node,item));default:case"every":return condition.every(item=>matches(node,item))}else if(matches(node,condition))return!0;return!1},$.fadeIn=(to=1,options)=>element&&0!==element.length?to<0?(console.warn("[$.fadeIn] Supplied end value parameter of 0 or less. Please use $.fadeOut or $.fadeToggle for that. This chain node will be skipped."),$):(options=formatAnimationOptions(options),map(element,node=>{$(node).animate(({start:start})=>{start({opacity:to},options)})}),$):$,$.fadeOut=(to=0,options)=>element&&0!==element.length?to>=1?(console.warn("[$.fadeOut] Supplied end value parameter of 1 or greater. Please use $.fadeIn or $.fadeToggle for that. This chain node will be skipped."),$):(options=formatAnimationOptions(options),map(element,node=>{$(node).animate(({start:start})=>{start({opacity:to},options)})}),$):$,$.fadeToggle=(from=0,to=1,options)=>element&&0!==element.length?(options=formatAnimationOptions(options),map(element,node=>{const opacity=parseFloat(styleProp(node,"opacity"));opacity>from?$(node).fadeOut(from,options):opacity<to&&$(node).fadeIn(to,options)}),$):$,$.attr=(property,value)=>{if(element&&0!==element.length){if(property)return value?void map(element,node=>{isArr(property)?isArr(value)?property.map((prop,index)=>node.setAttribute(prop,value[index])):property.map(prop=>node.setAttribute(prop,value)):isArr(value)?console.warn("[$.attr] Cannot set array of values to a single property."):node.setAttribute(property,value)}):isArr(property)?property.map(prop=>element[0].getAttribute(prop)):element[0].getAttribute(property);console.warn("[$.attr] Did not provide required property name(s).")}},$};return $}));
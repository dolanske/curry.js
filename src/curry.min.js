"use strict";function getStyleProperty(el,property){return window.getComputedStyle(el,null).getPropertyValue(property)}function isObject(value){let type=typeof value;return null!=value&&("object"==type||"function"==type)}function isArray(value){return Array.isArray(value)}function isNil(value){return null==value}function from(n,start=0){return Array.from({length:n},(_,i)=>i+start)}function isNodeMap(list){return void 0!==list.length}function undef(property,def){return isNil(property)?def:property}function bez(...args){if("string"==typeof args[0]&&1===args.length){const bezoars={easeInSine:[.12,0,.39,0],easeOutSine:[.61,1,.88,1],easeInOutSine:[.37,0,.63,1],easeInCubic:[.32,0,.67,0],easeOutCubic:[.33,1,.68,1],easeInOutCubic:[.65,0,.35,1],easeInQuint:[.64,0,.78,0],easeOutQuint:[.22,1,.36,1],easeInOutQuint:[.83,0,.17,1],easeInCirc:[.55,0,1,.45],easeOutCirc:[0,.55,.45,1],easeInOutCirc:[.85,0,.15,1],easeInQuad:[.11,0,.5,0],easeOutQuad:[.5,1,.89,1],easeInOutQuad:[.45,0,.55,1],easeInQuart:[.5,0,.75,0],easeOutQuart:[.25,1,.5,1],easeInOutQuart:[.76,0,.24,1],easeInExpo:[.7,0,.84,0],easeOutExpo:[.16,1,.3,1],easeInOutExpo:[.87,0,.13,1],easeInBack:[.36,0,.66,-.56],easeOutBack:[.34,1.56,.64,1],easeInOutBack:[.68,-.6,.32,1.6]},bez=args[0];if(bezoars[bez])return`cubic-bezier(${bezoars[bez].join(",")})`;throw Error(`Selected easing function "${bez}" doesn't exist.`)}const format=args.map(item=>Math.max(Math.min(item,1),0));return`cubic-bezier(${format.join(",")})`}function bindListener(el,name,callback,$state,options){el.addEventListener(name,e=>{callback({event:e,e:e,self:el,$util:$util,$state:$state})},options)}function map(elements,callback){if(isNodeMap(elements))for(let i=0;i<elements.length;i++)callback(elements[i],i)}function render(tag,attrs,children){return("string"==typeof attrs||"number"==typeof attrs||Array.isArray(attrs))&&(children=attrs,attrs={}),isNil(children)||(Array.isArray(children)?"string"==typeof children[0]&&(children=children[0]):children=`${children}`),{tag:tag,attrs:attrs,children:children}}function getSiblingIndex(el){if(!el)return 0;let i=0,cloned=el;for(;null!=(cloned=cloned.previousElementSibling);)i++;return i}function createElement(vnode,container,where){if(isArray(vnode))return void vnode.map(node=>createElement(node,container,where));const el=vnode.el=document.createElement(vnode.tag);if(vnode.attrs)for(const key in vnode.attrs){let value=vnode.attrs[key];el.setAttribute(key,value)}switch(vnode.children&&("string"==typeof vnode.children?el.textContent=vnode.children:vnode.children.forEach(child=>{"string"==typeof child?el.textContent+=" "+child:createElement(child,el)})),where){case"prepend":container.parentNode.insertBefore(el,container);break;case"append":container.parentNode.insertBefore(el,container.nextSibling);break;case"prependchild":container.insertBefore(el,container.firstChild);break;case"appendchild":default:container.appendChild(el)}return el}const $util={getStyleProperty:getStyleProperty,isObject:isObject,isArray:isArray,isNil:isNil,from:from,render:render,isElements:isNodeMap,mapElements:map,getSiblingIndex:getSiblingIndex,undef:undef,bez:bez};function queryElement(selector){if(isObject(selector)||selector.nodeType)return selector;let el=document.querySelectorAll(selector);return el&&1===el.length&&(el=el[0]),el}!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?module.exports=factory():"function"==typeof define&&define.amd?define(factory):(global=global||self).$=factory()}(this,(function(){const $state={},$=selector=>{let element;if(!selector)throw Error("Selector cannot be empty.");if("string"==typeof selector&&selector.startsWith("$"))switch(selector){case"$state":return $state;case"$util":return $util;default:throw Error("Unsupported magic selector.")}element=queryElement(selector),$.get=property=>{if(element&&0!==element.length){if(property){if(isNodeMap(element)){const params=[];return map(element,el=>{el[property]&&params.push(el[property])}),params}if(element[property])return[element[property]]}return 1===element.length?element[0]:element}},$.del=()=>{element&&(isNodeMap(element)?map(element,node=>node.remove()):element.remove())},$.on=(event,callback,options)=>{if(!element)return $;if(isNodeMap(element))for(const item of element)bindListener(item,event,callback,$state,options);else bindListener(element,event,callback,$state,options);return $},$.css=(property,style)=>element?property?"string"==typeof property&&"string"==typeof style?(element.style[property]=style,!0):isObject(property)?(Object.entries(property).map(([key,value])=>{element.style[key]=value}),!0):void 0:(console.warn("No style entered"),!1):$,$.addClass=classNames=>element?classNames&&0!==classNames.length?isArray(classNames)?(classNames.map(item=>element.classList.add(item)),!0):"string"==typeof classNames?(element.classList.add(classNames),!0):void 0:(console.warn("No class name(s) entered"),!1):$,$.delClass=classNames=>element?classNames&&0!==classNames.length?isArray(classNames)?(classNames.map(item=>element.classList.remove(item)),!0):"string"==typeof classNames?(element.classList.remove(classNames),!0):void 0:(console.warn("No class name(s) entered"),!1):$,$.toggleClass=classNames=>{if(!element)return $;if(!classNames||0===classNames.length)return console.warn("No class name(s) entered"),!1;const toggle=cls=>{element.classList.contains(cls)?element.classList.remove(cls):element.classList.add(cls)};isArray(classNames)&&classNames.map(item=>toggle(item)),"string"==typeof classNames&&toggle(classNames)},$.each=callback=>{if(!element)return $;if(!callback)throw Error("Callback must be a function");if(void 0===element.length)callback({self:element,$util:$util,index:0,$state:$state});else{let prev=null,index=0;for(const el of element)callback({self:el,prev:prev,$util:$util,index:index,$state:$state}),prev=el,index+=1}return $},$.asyncEach=async callback=>{if(!element)return $;if(!callback)throw Error("Callback must be a function");if(void 0===element.length)callback({self:element,$util:$util,index:0,$state:$state});else{let prev=null,index=0;for(const el of element)await new Promise(resolve=>callback({self:el,prev:prev,$util:$util,index:index,next:resolve,$state:$state})),prev=el,index+=1}return $},$.nth=(index,callback)=>{if(!element)return $;if(isNodeMap(element)){if(index>element.length)return;if(index&&1!==index){for(let i=0;i<=element.length;i++)if(index-1===i){element=element[i];break}}else element=element[0]}return callback&&callback({self:element,$util:$util,index:index,$state:$state}),$},$.nthChild=(n,callback)=>{if(!element)return $;if(isNodeMap(element)){if(1!==element.length)throw Error("Cannot use function $.next() on a HTMLCollection. Wrap your functionality in the $.each() iterator.");element=element[0]}return n>element.children.length?void 0:(n&&1!==n||(element=element.firstElementChild),element.children&&n>1&&map(element.children,(child,index)=>{n-1===index&&(element=child)}),callback&&callback({self:element,$util:$util,index:n,$state:$state}),$)},$.children=callback=>{if(!element)return;if(isNodeMap(element)){if(1!==element.length)throw Error("Cannot use function $.children() on a HTMLCollection. Wrap your functionality in the $.each() iterator.");element=element[0]}if(0===element.children.length)return;const self=element;return element=element.children,callback&&callback({self:self,children:element.children,$util:$util,$state:$state}),$},$.next=(index,callback)=>selectNTHSibling("next",index,callback),$.prev=(index,callback)=>selectNTHSibling("prev",index,callback);const selectNTHSibling=(selectType,index,callback)=>{if(!element)return $;const type="next"===selectType?"nextElementSibling":"previousElementSibling";if(isNodeMap(element)){if(1!==element.length)throw Error("Cannot use function $.next() on a HTMLCollection. Wrap your functionality in the $.each() iterator.");element=element[0]}if("number"!=typeof index&&(callback=index,index=null),!element[type])return element=void 0,$;if(index){const prev=element;for(let i=0;i<index;i++)element[type]&&(element=element[type]);callback&&callback({self:element,prev:prev,index:getSiblingIndex(element),$util:$util,$state:$state})}else callback&&callback({self:element[type],prev:element,index:getSiblingIndex(element[type]),$util:$util,$state:$state}),element=element[type];return $};$.first=callback=>element?(isNodeMap(element)&&(element=element[0]),callback&&callback({self:element,$util:$util,$state:$state}),$):$,$.last=callback=>{if(!element)return $;let index=0;return isNodeMap(element)&&(index=element.length-1,element=element[index]),callback&&callback({self:element,$util:$util,index:index,$state:$state}),$},$.append=callback=>{if(!element)return $;const vdom="function"==typeof callback?callback({self:element,render:render,$util:$util,$state:$state}):callback;if("string"==typeof vdom)if(isNodeMap(element))for(const el of element)el.insertAdjacentHTML("afterend",vdom);else element.insertAdjacentHTML("afterend",vdom);else isNil(vdom)||(isNodeMap(element)?map(element,node=>createElement(vdom,node,"append")):createElement(vdom,element,"append"));return $},$.prepend=callback=>{if(!element)return $;const vdom="function"==typeof callback?callback({self:element,render:render,$util:$util,$state:$state}):callback;if("string"==typeof vdom)if(isNodeMap(element))for(const el of element)el.insertAdjacentHTML("beforebegin",vdom);else element.insertAdjacentHTML("beforebegin",vdom);else isNil(vdom)||(isNodeMap(element)?map(element,node=>createElement(vdom,node,"prepend")):createElement(vdom,element,"prepend"));return $},$.addChild=(callback,append=!0)=>{if(!element)return $;const vdom="function"==typeof callback?callback({self:element,render:render,$util:$util,$state:$state}):callback;return"string"==typeof vdom?isNodeMap(element)?map(element,node=>node.insertAdjacentHTML(append?"beforeend":"afterbegin",vdom)):element.insertAdjacentHTML(append?"beforeend":"afterbegin",vdom):isNil(vdom)||(isNodeMap(element)?map(element,node=>{createElement(vdom,node,append?"appendchild":"prependchild")}):createElement(vdom,element,append?"appendchild":"prependchild")),$},$.text=(text,location="replace")=>{if(!element)return $;if(!["replace","prepend","append"].includes(location))return console.warn(`Function $.text(text, location) doesn't accept parameter "${location}" as a valid argument.`,"Please use 'replace', 'prepend' or 'append'"),$;const setText=(el,text,location)=>{switch(location){case"prepend":el.insertAdjacentText("afterbegin",text);break;case"append":el.insertAdjacentText("beforeend",text);break;default:case"replace":el.textContent=text}};return isNodeMap(element)?map(element,node=>setText(node,text,location)):setText(element,text,location),$},$.show=(display="block")=>{if(!element)return $;if(isNodeMap(element))for(const el of element)el.style.display=display;else element.style.display=display;return $},$.hide=()=>{if(!element)return $;if(isNodeMap(element))for(const el of element)el.style.display="none";else element.style.display="none";return $},$.toggle=(onActive="block")=>{if(!element)return $;const isActive="none"!==getStyleProperty(isNodeMap(element)?element[0]:element,"display"),toggleSelf=(active,element,onActive)=>{active?$(element).hide():$(element).show(onActive)};if(isNodeMap(element))for(const el of element)toggleSelf(isActive,el,onActive);else toggleSelf(isActive,element,onActive);return $},$.hover=functions=>{if(!element)return $;const{enter:enter,leave:leave,options:options}=functions;if(!enter||!leave)throw Error("Function $.hover({ enter, leave }) requires both parameters.");if(isNodeMap(element))for(const el of element)$(el).on("mouseenter",args=>enter({...args}),options),$(el).on("mouseleave",args=>leave({...args}),options);else $(element).on("mouseenter",args=>enter({...args}),options),$(element).on("mouseleave",args=>leave({...args}),options);return $},$.click=(callback,options)=>element&&callback?(isNodeMap(element)?map(element,node=>{$(node).on("click",args=>callback({...args}),options)}):$(element).on("click",args=>callback({...args}),options),$):$,$.parent=callback=>{if(element){if(isNodeMap(element)){const fragment=document.createDocumentFragment();map(element,node=>{if(node&&node.parentNode){const parent=node.parentNode;callback&&callback({self:parent,child:node,$util:$util,$state:$state}),fragment.appendChild(parent.cloneNode(!0))}}),element=fragment.children}else if(element&&element.parentNode){const parent=element.parentNode;callback&&callback({self:parent,child:element,$util:$util,$state:$state}),element=parent}return $}},$.exe=callback=>element&&callback?(callback({self:element,$util:$util,$state:$state}),$):$,$.filter=callback=>{if(!element)return $;if(callback||console.warn("No condition to iterate on, this chain node will be skipped."),isNodeMap(element)){const filtered=[];map(element,(node,index)=>{const result=callback({self:node,index:index,$util:$util,$state:$state});result&&filtered.push(node)}),element=filtered}else{const result=callback({self:element,$util:$util,$state:$state,index:0});result||(element=void 0)}return $},$.animate=async(properties,options)=>{if(!element||!properties)return $;const formatOptions=(options={})=>({length:undef(options.length,500),easing:undef(options.easing,"ease-in-out"),callback:options.callback,defaultUnit:undef(options.defaultUnit,"px")});if(options=formatOptions(options),"function"==typeof properties){const execute=properties;async function start(properties,options){if(options=formatOptions(options),isNodeMap(element)){const promises=[];for(const el of element)promises.push(applyAnimation(el,properties,options));return Promise.all(promises)}return applyAnimation(element,properties,options)}await execute({self:element,$util:$util,start:start,$state:$state})}else isNodeMap(element)?map(element,node=>applyAnimation(node,properties,options)):applyAnimation(element,properties,options);return $};const applyAnimation=async(el,properties,options)=>{const{length:length,easing:easing,callback:callback,defaultUnit:defaultUnit}=options,prevTransition=el.style.transition;let duration=length;return"string"==typeof length&&length.endsWith("s")&&(duration=1e3*parseFloat(length.slice(0,-1))),el.style.transition=`${duration/1e3}s all ${easing}`,new Promise(resolve=>{Object.entries(properties).map(([index,value])=>{const property=index;"number"==typeof value&&(value+=defaultUnit),el.style[property]=value}),setTimeout(()=>resolve(),duration)}).then(()=>{el.style.transition=prevTransition,callback&&callback({self:el,$util:$util,$state:$state})})};return $.slideDown=(duration=500,easing="ease-in-out")=>{if(!element)return $;const sd=el=>{el.style.display="block",el.style.overflow="hidden",el.style.height=0;const height=el.scrollHeight;$(el).animate({height:height},{duration:duration,easing:easing,callback:({self:self})=>{self.style.overflow="inherit",self.style.height="inherit"}})};return isNodeMap(element)?map(element,node=>sd(node)):sd(element),$},$.slideUp=(duration=500,easing="ease-in-out")=>{if(!element)return $;const su=el=>{el.style.overflow="hidden",el.style.height=el.scrollHeight,setTimeout(()=>{$(el).animate({height:0},{duration:duration,easing:easing,callback:({self:self})=>{self.style.display="none"}})},1)};return isNodeMap(element)?map(element,node=>su(node)):su(element),$},$.slideToggle=(duration=500,easing="ease-in-out")=>{if(!element)return $;const st=el=>{"none"===el.style.display?$(el).slideDown(duration,easing):$(el).slideUp(duration,easing)};return isNodeMap(element)?map(element,node=>st(node)):st(element),$},$};return $}));